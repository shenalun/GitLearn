/*
Git是分布式版本控制系统，--global参数表示这台机器上所有的Git仓库都会使用这个配置
也可以对某个仓库指定不同的用户名和Email
*/
01	git config --global user.name "shenalun"
02	git config --global user.email "shenalun@163.com"
===========================================================================================
/*
把当前目录初始化成Git可以管理的目录,当前目录下出现的.git文件就是用来跟踪管理版本库的
*/
03	git init
===========================================================================================
/*
把文件xxx添加到暂存区
*/
04	git add xxx
===========================================================================================
/*
把文件xxx提交到仓库,-m后面输入的是本次提交的说明，最好有意义，方便从历史记录里找到改动
commit可以一次提交很多文件，可以多次add不同的文件，比如：
	git add file1.txt
	git add file2.txt file3.txt
	git commit -m "add 3 files"
*/
05	git commit -m "read_me"
===========================================================================================
/*
时刻掌握仓库当前的状态,git status指示有文件改动,git diff可以查看修改内容
*/
06	git status
===========================================================================================
/*
工作区与暂存区之间文件版本的差异,如果已经commit，则对比工作区与仓库的版本差异
如果仅仅是add,没有commit,对比工作区与暂存区版本差异
*/
07	git diff 
===========================================================================================
/*
显示从最近到最远的提交日志，可以加上--pretty=oneline参数,comint id号是一大串数字
*/
08	git log
08	git log --pretty=oneline
===========================================================================================
/*
在Git中HEAD表示当前版本，上一个版本是HEAD^,上上个版本是HEAD^^,HEAD~3指的是上3个版本,以此类
推HEAD~n 代表上n个版本,版本回退,该命令执行后，用git log则查不到(回退后的版本)之后提交的记录
*/
09	git reset --hard HEAD^
===========================================================================================
/*
若回退版本后,再想回去，如果当前命令行窗口没有关闭，则顺着窗口往上找，找到提交的commit id,可以
通过指定commit id 的方式回到指定的版本,该指是一大串哈希值，可以简写前几个数字，Git自动索引
git版本回退的速度非常快，git内部有个指向当前版本的HEAD指针，当回退版本时，Git仅仅是把HEAD指针
的指向移动个位置，顺便把工作区给更新了，故HEAD指向哪个版本号，当前版本就定位在哪。
*/
10	git reset--hard <commit id>
===========================================================================================
/*
若窗口关闭,关闭电脑,仍然想恢复到最新版本,找不到commit id可以使用以下命令,该命令记录用户每一次
命令,git log 可以查看提交历史，以便确定要回到哪个版本；git reflog 查看命令历史，以便确定要回到
哪个版本
*/
11	git reflog
===========================================================================================
/*
丢弃工作区的修改：1、若文件自修改后还没有放到暂存区，那么执行这个命令撤销修改就回到版本库一模
一样的状态；2、文件已经添加到暂存区，又做了修改，那么撤销修改就回到添加到暂存区后的状态。
总之该命令将文件回到最近一次git commit 或 git add 状态
*/
12	git checkout -- file 
12	git restore  -- file
===========================================================================================
/*
丢弃暂存区的修改,即文件不暂存，回到工作区状态，在commit之前，把暂存区的修改撤销掉，回到
工作区当前状态，即工作区目前是什么状态就保持在什么状态
*/
13	git reset HEAD file
13	git	restore --staged file
===========================================================================================
总结：
场景1：当改乱了工作区某个文件内容，想直接丢弃工作区的修改时，用命令git checkout -- file；
场景2：当不但改乱了工作区某个文件的内容，还添加到了暂存区，像丢弃修改分两步，第一步用
	git reset HEAD file，就回到场景1，第二步按场景1操作；
场景3：已经提交了改乱的代码到版本库，想要撤销本次提交，可以使用版本回退，前提是没有推送
	到远程库
===========================================================================================
/*
在Git中，删除也是一个修改操作，前提是该文件被Git管理。若在文件管理器中删除没用的文件，Git会告知
工作区和版本库不一致，且会告知哪些文件被删除，如果确实需要从版本库中删除该文件使用以下命令，并且
git commit
*/
14	git rm file 
	git commit -m"remove something"
/*
另一种情况是删错了，版本库里仍然存在，那么可以使用(丢弃工作区的修改)命令，可以很轻松的把误删的文件
恢复到版本库里面最新版，本质是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，该命令
都可以一键还原，若文件已经提交到版本库，那么永远不用担心误删，但是，只能恢复文件到版本库最新版，
会丢失提交后你继续修改的内容
*/
15	git checkout -- file (the same as 12)
===========================================================================================
/*
关联远程仓库
*/
16	git remote add origin git@github.com:shenalun/GitLearn.git
===========================================================================================
/*
把本地仓库的内容推送到GitHub仓库，git push 命令把当前分支master推送到远程，第一次推送master分支时，
加上-u参数，Git不但会把本地的master分支内容推送到远程新的origin/master分支上，还会把本地的master分支
和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令git push/pull
若上传远程仓库出错，先把远程仓库拉下来，会自动合并的，再上传
*/
17	git pull origin master 
	git push -u origin master
===========================================================================================	
/*
如果pull时出错 添加参数 --allow-unrelated-histories 把两段不相干的分支进行强行合并，后面再push就可以了
*/	
18	git pull origin master --allow-unrelated-histories
	git push origin master
	git push		//或者直接使用更简化命令
===========================================================================================	
/*
要克隆一个仓库，首先必须知道仓库的地址，然后使用git clone命令克隆，Git支持多种协议，包括https，
但ssh协议速度最快
*/		
19	git clone git@github.com:shenalun/DriverLibraryInteraction_CrossPlatform_Git.git	
===========================================================================================	
/*
HEAD严格上来说不是指向提交，而是指向master,master才是指向提交的，所以HEAD指向的就是当前分支
创建并切换分支用以下命令 -b参数表示创建并切换
*/
20	git checkout -b xxx
20	git switch -c xxx

相当于：
21	git branch xxx	
	git checkout xxx   /   git switch xxx
===========================================================================================	
/*
查看当前分支,该命令会列出所有分支，当前分支前面会标一个*以示区分
*/
22 git branch

23	test:Creating a new branch is quick
24	test:Forbidden Past-forward

===========================================================================================	
/*
合并指定分支到当前分支，Fast-forward快进模式，若当前在master分支，执行git merge dev
直接把master指向dev的当前提交，合并完成可以放心删除dev分支
*/
25	git merge xxx 
===========================================================================================	
总结：
查看分支：				git branch
创建分支：				git branch xxx
切换分支：				git checkout xxx 或者 git switch xxx
创建+切换分支：			git checkout -b xxx 或者 git switch -c xxx
合并某分支到当前分支：	git merge xxx 
删除分支：				git branch -d xxx 
===========================================================================================	
in master branch:
	26	test:in feature1 branch already add 26，test conflict
in feature1 branch:
	26	test:Creating a new branch is feature1
===========================================================================================	
总结：
当Git无法自动合并分支时，必须先解决冲突。解决冲突后git add 然后git commit 合并完成。
===========================================================================================	
/*
查看分支合并图
*/
27	git log --graph
===========================================================================================	
/*
合并分支时，如果可能，Git会使用Fast forward 模式，但这种情况下，删除分支后，会丢掉分支信息
如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出
分支信息，使用--no-ff参数禁用 Fast模式，以下命令表示合并xxx分支到当前分支，并做一次提交说明
代表本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去
*/
28	git merge --no-ff -m"say something" xxx 
===========================================================================================	
分支管理策略：
总结：
master分支应该是非常稳定的，也就是仅用来发布版本，平时不能在上面干活，干活都在dev分支，dev分支
是不稳定的，到某个时候，比如1.0版发布时，再把dev分支合并到master上，在master分支发布1.0版本
你和你的小伙伴每个人都在dev分支上干活，每个人都有自己的分支，时不时往dev分支上合并就可以了。
合并分支时，加上--no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出曾经做过合并，而
fast forward合并就看不出曾经做过合并。
===========================================================================================	
/*
软件开发中，bug就像家常便饭一样。有了bug就需要修复，在Git中，由于分支是如此的强大，所以每个bug
都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。
*/
29	test:
===========================================================================================	
/*
当接到一个修复bug的任务时，当前正在dev分支上的活还没有干完，工作没有提交，并不是不想提交，而是
工作只进行到一半，还没法提交，预计完成还需一天时间。但是必须在两个小时内修复bug，Git提供了stash
功能，可以把当前工作现场储藏起来，等以后恢复现场后继续工作
*/
30	git stash
===========================================================================================	
/*
修复完bug，接着回到dev上干活，这时候git status 工作区是干净的用以下命令，找到之前的工作现场
*/
31	git stash list
===========================================================================================	
/*
工作现场找到后，有两个办法恢复：
一、git stash apply 恢复，但是恢复后，stash内容并不删除，需要用git stash drop来删除；
二、另一种方式使用git stash pop ，恢复的同时把stash内容也删了。
*/
32	git stash apply
	git stash drop
	
33	git stash pop
===========================================================================================	
/*
同样可以不用删除stash，也可以多次stash，恢复的时候先用git stash list 查看，然后恢复指定的stash
*/
34	git stash apply stash@{x}
===========================================================================================	
/*
在master分支上修复的bug在dev分支上同样存在，同样的bug不需要在dev分支上重复进行一次，可以把修复
bug的提交所作的修改拷贝到dev分支上，并不是把整个master分支merge过来，为了方便操作，使用以下命令
能复制一个特定的提交到当前分支，以下xxx表示提交的commit id 一大串哈希值的简写
*/
35	git cherry-pick xxx